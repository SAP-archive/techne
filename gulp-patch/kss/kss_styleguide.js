var KssStyleguide, sectionQueryMatch;

/**
 * An instance of this class is returned on finishing `kss.traverse`.
 * Exposes convenience methods for interpreting data.

 * @param {Object} data The data object generated by traverse.
 */
module.exports = KssStyleguide = function (data) {
	if (!(this instanceof KssStyleguide)) {
		return new KssStyleguide();
	}
	this.data = data || {};
	this.init();
};

KssStyleguide.prototype.init = function () {

};

KssStyleguide.prototype.section = function( query, qType) {
	var i, l ,
		current, isExact = false,
		sections = [];

    //@TODO do something with the qType so that when called with we look only at the page type posibilities that match the passed qType instead of all sections

	if (!query) {
		return this.section(/.+/);
	}
   /* 
    console.log('----------------------------------------------------------');
    console.log('----------------------------------------------------------');
    console.log('------------------  NEW SECTION CHECK  -------------------');
    console.log('----------------------------------------------------------');
    console.log('----------------------------------------------------------');
    console.log('original query', query);
    */
	// Exact Queries
	if (typeof query === 'string') {
		isExact = query.match(/[0-9\.]*/);
		if (isExact && isExact[0] === query) {
			if (this.data.section_refs && this.data.section_refs[query]) {
				return this.data.section_refs[query];
			} else {
				return false;
			}
		}
	}

	// If recieving a n.x or n.* query, convert it
	// to regex for general search
	if (!(query instanceof RegExp)) {

        //console.log('orig query', query);
		query = new RegExp(

			query
			 .replace(/\*/g, '([0-9]\\.?)*')
			 .replace(/x/g, '[0-9]*')
		);
	}


    l = (qType)? qType.length : this.data.sections.length;

	// General (regex) search
	for (i = 0; i < l; i += 1) {
        
		current = (qType != undefined)? qType[i] : this.data.sections[i];

		if (sectionQueryMatch(current.data.reference, query)) {
			sections.push(current);
            //console.log('push current', sections);
		}
	}
    

	if (!sections) {
		return false;
	}

    /*
    console.log('------------------  FINAL SECTION LIST -------------------');
    console.log(sections);
    */

	// Sorts results based on reference number.
	return sections.sort(function(a, b) {
		var refsA = a.data.reference.split('.'),
			refsB = b.data.reference.split('.'),
			rLengthA = refsA.length,
			rLengthB = refsB.length,
			i, l = Math.max(refsA.length, refsB.length);

		for (i = 0; i < l; i += 1) {
			if (refsA[i] && refsB[i]) {
				if (refsA[i] != refsB[i]) {
					return refsA[i] - refsB[i];
				}
			} else {
				return refsA[i] ? +1 : -1;
			}
		}

		return 0;
	});
};

sectionQueryMatch = function(reference, query) {
  	var match = reference.match(query);
    if((match && match[0] === reference))
    {
        /*
        console.log(" ");
        console.log("---------------------------------------------");
        console.log("query :: "+ query + " ; reference :: "+ reference +" ; match :: " + match[0] );
        console.log('dose it match?', (match && match[0] === reference));
        console.log("---------------------------------------------");
        console.log(" ");
        */
    }
	return match && match[0] === reference;
}
